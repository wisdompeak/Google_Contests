https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050e01/000000000006987d

#### 解法1

首先用多源的BFS得到每个点到最近的邮局的距离，构建steps矩阵，时间是o(RC)。

然后遍历每个点(x,y)，我们都尝试一下它是否可能是新的邮局地点。对于每个新邮局的地点，我们都遍历所有其他地点(i,j)，看(i,j)到这个新邮局的距离d(i,j)，并和steps[i][j]取较小值，这就是(i,j)在新邮局体系下的最小距离。遍历所有(i,j)后，我们就能够得到如果选地点(x,y)作为新邮局的话，全局的最长距离。

当然我们是要遍历所有的(x,y)的，因此时间复杂度是o(RC\*RC)。

#### 解法2
用二分法，考察K是否能够是满足答案的条件。

首先，我们利用steps矩阵过滤掉目前为止，已经满足到最近邮局距离小于等于K的那些地点。对于剩下的那些地点，我们记作Set.

然后我们遍历所有可以作为新邮局的地点(x,y)。如果可以快速判断(x,y)到Set里所有地点曼哈顿距离里的最大值也小于等于K，那么(x,y)就是一个合适的地点。那么怎么判断呢？其实我们可以预处理Set，就可以在o(1)时间内做出判断。

证明：对于任何(a1,b1),(a2,b2)两点间的曼哈顿距离：
```
|a1-a2|+|b1-b2| = max {a1-a2+b1-b2, a1-a2-b1+b2, -a1+a2+b1-b2, -a1+a2-b1+b2} = 
max of { (a1+b1)-(a2+b2),  (a1-b1)-(a2-b2), (-a1+b1)-(-a2+b2), (-a1-b2)-(-a1-b1)}
```
也就是说如果我们第二个点为(x,y)，我们要找Set里面某个(a,b)到(x,y)的距离最大，只需要提前在Set里面找到最大化的(a+b), (a-b), (-a+b), (-a-b)四个数即可，然后取 { (a+b)-(x+y),  (a-b)-(x-y), (-a+b)-(-x+y), (-a-b)-(-x-y)} 中的最大值。

