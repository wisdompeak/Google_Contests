我们将这M堆数字始终按照从大到小排序。最终的状态就是target。我们令dfs(cur)表示从当前状态到达target所需要的额外投掷次数的期望。其中cur也是M维的向量，代表每种数字的个数。但是注意，cur也始终保持从大到小的排列。

假设M = 6, target = (3,2,2,0,0,0)，cur = (3,1,1,0,0,0). 
                                          a b c d e f

我们将cur对应的六个数值标记为abcdef. 可以知道，我们如果再骰出a的话（概率是1/M），a就有4个了，显然不是达成target的最优方案，需要重骰，而且cur保持不变。

如果我们我们再骰出的是b（概率是1/M），那么cur就会变成(3,2,1,0,0,0)，这是继续通往target的一条路。所以达成(3,1,1,0,0,0)的期望可以更新为：dfs(3,1,1,0,0,0) += (dfs(3,2,1,0,0,0)+1)*1/M。同理，如果我们再骰出的是c，那么cur也会变成(3,2,1,0,0,0)，所以综上，dfs(3,1,1,0,0,0) += (dfs(3,2,1,0,0,0)+1)*2/M，其中2的统计方法是查看cur有多少个与b相同的元素。

更抽象地说，如果cur[i]到cur[j]的频次都相同，并且cur[i]<target[i]，这意味着我们骰出i到j的任意一个元素，cur都会变成这样一个新状态 newState = (...cur[i]+1,cur[i+1],...cur[j],....)，并且这个newState是能够继续通往target的有效状态. 我们可以更新达成cur的次数的期望 ```dfs(cur) += (dfs(newState)+1) * (j-i+1)*1/M```. 

此外，我们还要计算retoll的次数。就是当cur[i]==target[i]时，意味着我们骰出i的话就超过了target，必须重骰，而且状态向量不变（因为没有任何一个数值得到了有效的更新）。

所以我们有方程式： ```dfs(cur) = sum{ (dfs(newState)+1)*len*1/M } + (dfs(cur)+1) * retoll *1/M```，化简得到
```
dfs(cur) = (sum{ (dfs(newState)+1)*len*1/M } + retoll * 1.0/M) / (1.0 - retoll * 1.0/M);
```
